#pragma once

// Generated by gen_reflection_header.py

namespace reflection {
#define REFL_BEGIN(className_, version_) \
public:\
    static const char* reflection_s_classId(REFL_MATCH_0) { return className_ "," #version_; }\
    static const char* reflection_s_className(REFL_MATCH_0) { return className_; }\
    static bool reflection_s_isPolymorphic(REFL_MATCH_0) { return false; }\
    const char* reflection_classId(REFL_MATCH_0) const { return className_ "," #version_; }\
    const char* reflection_className(REFL_MATCH_0) const { return className_; }\
    const ::reflection::UUID_t* reflection_uuidOrNull(REFL_MATCH_1) const { return nullptr; }\
    ::reflection::FieldSet_t const* reflection_getFields(REFL_MATCH_0) const {\
        typedef std::remove_reference<decltype(*this)>::type ThisClass;\
        return reflection_s_getFields<ThisClass>(REFL_MATCH);\
   }\
    template <class ThisClass>\
    static ::reflection::FieldSet_t const* reflection_s_getFields(REFL_MATCH_0) {\
        const char* thisClassName = className_;\
        thisClassName = thisClassName;\
        ::reflection::FieldSet_t const* baseClassFields = nullptr;\
        void* (*derivedPtrToBasePtr)(void*) = nullptr;\
        static ::reflection::Field_t const fields[] = {\


#define REFL_BEGIN_EXTENDS(className_, version_, baseClass_) \
public:\
    static const char* reflection_s_classId(REFL_MATCH_0) { return className_ "," #version_; }\
    static const char* reflection_s_className(REFL_MATCH_0) { return className_; }\
    static bool reflection_s_isPolymorphic(REFL_MATCH_0) { return false; }\
    const char* reflection_classId(REFL_MATCH_0) const { return className_ "," #version_; }\
    const char* reflection_className(REFL_MATCH_0) const { return className_; }\
    const ::reflection::UUID_t* reflection_uuidOrNull(REFL_MATCH_1) const { return nullptr; }\
    ::reflection::FieldSet_t const* reflection_getFields(REFL_MATCH_0) const {\
        typedef std::remove_reference<decltype(*this)>::type ThisClass;\
        return reflection_s_getFields<ThisClass>(REFL_MATCH);\
   }\
    template <class ThisClass>\
    static ::reflection::FieldSet_t const* reflection_s_getFields(REFL_MATCH_0) {\
        const char* thisClassName = className_;\
        thisClassName = thisClassName;\
        ::reflection::FieldSet_t const* baseClassFields = baseClass_::reflection_s_getFields<baseClass_>(REFL_MATCH);\
        void* (*derivedPtrToBasePtr)(void*) = &::reflection::derivedPtrToBasePtr<ThisClass, baseClass_>;\
        static ::reflection::Field_t const fields[] = {\


#define REFL_BEGIN_VIRTUAL(className_, version_) \
public:\
    static const char* reflection_s_classId(REFL_MATCH_0) { return className_ "," #version_; }\
    static const char* reflection_s_className(REFL_MATCH_0) { return className_; }\
    static bool reflection_s_isPolymorphic(REFL_MATCH_0) { return true; }\
    virtual const char* reflection_classId(REFL_MATCH_0) const { return className_ "," #version_; }\
    virtual const char* reflection_className(REFL_MATCH_0) const { return className_; }\
    virtual const ::reflection::UUID_t* reflection_uuidOrNull(REFL_MATCH_1) const { return nullptr; }\
    virtual ::reflection::FieldSet_t const* reflection_getFields(REFL_MATCH_0) const {\
        typedef std::remove_reference<decltype(*this)>::type ThisClass;\
        return reflection_s_getFields<ThisClass>(REFL_MATCH);\
   }\
    template <class ThisClass>\
    static ::reflection::FieldSet_t const* reflection_s_getFields(REFL_MATCH_0) {\
        const char* thisClassName = className_;\
        thisClassName = thisClassName;\
        ::reflection::FieldSet_t const* baseClassFields = nullptr;\
        void* (*derivedPtrToBasePtr)(void*) = nullptr;\
        static ::reflection::Field_t const fields[] = {\


#define REFL_BEGIN_VIRTUAL_EXTENDS(className_, version_, baseClass_) \
public:\
    static const char* reflection_s_classId(REFL_MATCH_0) { return className_ "," #version_; }\
    static const char* reflection_s_className(REFL_MATCH_0) { return className_; }\
    static bool reflection_s_isPolymorphic(REFL_MATCH_0) { return true; }\
    virtual const char* reflection_classId(REFL_MATCH_0) const { return className_ "," #version_; }\
    virtual const char* reflection_className(REFL_MATCH_0) const { return className_; }\
    virtual const ::reflection::UUID_t* reflection_uuidOrNull(REFL_MATCH_1) const { return nullptr; }\
    virtual ::reflection::FieldSet_t const* reflection_getFields(REFL_MATCH_0) const {\
        typedef std::remove_reference<decltype(*this)>::type ThisClass;\
        return reflection_s_getFields<ThisClass>(REFL_MATCH);\
   }\
    template <class ThisClass>\
    static ::reflection::FieldSet_t const* reflection_s_getFields(REFL_MATCH_0) {\
        const char* thisClassName = className_;\
        thisClassName = thisClassName;\
        ::reflection::FieldSet_t const* baseClassFields = baseClass_::reflection_s_getFields<baseClass_>(REFL_MATCH);\
        void* (*derivedPtrToBasePtr)(void*) = &::reflection::derivedPtrToBasePtr<ThisClass, baseClass_>;\
        static ::reflection::Field_t const fields[] = {\


}
